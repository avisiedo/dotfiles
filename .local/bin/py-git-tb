#!/usr/bin/python3
import sys
import os
import argparse
import logging
import subprocess

WORKSPACE = os.environ.get('WORKSPACE', os.path.join(os.environ['HOME'], 'workspace'))

class _:
    """Encapsulate the constants"""
    PROG = 'py-git-tb'
    GIT_PATH = 'git_path'
    GIT = 'git'
    HIDDEN_GIT = '.git'
    UTF_8 = 'utf-8'
    # Environmnet variable with the ordered list of priorities for upstream
    # in the workspace; by default is set to 
    # "upstream,origin" => ['upstream', 'origin']
    ENV_GIT_REMOTES = 'GIT_REMOTES'
    ENV_GIT_REMOTES = 'GIT_REMOTES'
    GIT_REMOTES_DEFAULT = 'upstream,origin'

    # os.walk return dirpath on index 0
    WALK_DIRPATH = 0
    # os.walk return dirnames on index 0
    WALK_DIRNAMES = 1
    # os.walk return filenames on index 0
    WALK_FILENAMES = 2

    # Subcommands
    SUBCMD_LIST = 'list'
    SUBCMD_CHECK = 'check'
    SUBCMD_PULL = 'pull'
    SUBCMD_PUSH = 'push'
    SUBCMD_BACKUP = 'backup'
    SUBCMD_RESTORE = 'restore'

    # Ignore node_modules which use to have a huge directory structure
    FILTER_NODE_MODULES = 'node_modules'
    # Ignore .venv which use to have a huge directory structure
    FILTER_VENV = '.venv'
    # List for the directories to filter to accelerate the .git traverse.
    FILTERS = (FILTER_NODE_MODULES, FILTER_VENV)

def git_tb_help():
    pass

def git(*args, **kargs):
    """Wrapper to invoke git commands"""
    if not _.GIT_PATH in kargs:
        raise KeyError("'{}'".format(_.GIT_PATH))
    return subprocess.run([_.GIT, *args], cwd=kargs[_.GIT_PATH], capture_output=True, **kargs)

def git_tb_all(basedir, f, *args, **kargs):
    for item in os.walk(basedir, topdown=True):
        if _.HIDDEN_GIT in item[_.WALK_DIRNAMES]:
            kargs[_.GIT_PATH] = basedir
            f(*args, **kargs)
        else:
            # Prune some well known directories
            for filter_item in _.FILTERS:
                if filter_item in item[_.WALK_DIRNAMES]:
                    item[_.WALK_DIRNAMES].remove(filter_item)
            # Recursive call to the remaining directories
            for new_dir in item[_.WALK_DIRNAMES]:
                git_tb_all(os.path.join(basedir, new_dir), f, *args, **kargs)
        break

def git_tb_list_helper(*args, **kargs):
    print('{}'.format(kargs[_.GIT_PATH]))

def git_tb_list():
    git_tb_all(WORKSPACE, git_tb_list_helper)

def git_tb_check_helper(*args, **kargs):
    logging.info('repository at: "{}"'.format(kargs[_.GIT_PATH]))
    result = git('status', *args, **kargs, capture_output=False)
    if result.returncode != 0:
        logging.warning('status return=\'{}\''.format(result.returncode))

def git_tb_check():
    git_tb_all(WORKSPACE, git_tb_check_helper, stdout=None)

def git_tb_pull_helper(*args, **kargs):
    logging.info('repository at: "{}"'.format(kargs[_.GIT_PATH]))
    git('pull', *args, **kargs)

def git_tb_pull(*args, **kargs):
    git_tb_all(WORKSPACE, git_tb_pull_helper)

def get_priority_git_remotes():
    remotes = os.environ.get(_.ENV_GIT_REMOTES, _.GIT_REMOTES_DEFAULT).split(',')
    return remotes

def git_tb_push_helper(*args, **kargs):
    try:
        cwd = kargs[_.GIT_PATH]
        res_remote = git('remote', cwd=cwd)
        remotes = res_remote.stdout.decode(_.UTF_8).split_lines()
        for remote in get_priority_git_remotes():
            if remote in remotes:
                git('push', remote, '--all', cwd=cwd)
                return
        logging.warning('{}: repository not pushed'.format(cwd))
    except Exception as e:
        logging.error('{}: {}'.format(cwd, e))

def git_tb_push():
    git_tb_all(WORKSPACE, git_tb_push_helper)

def git_tb_backup():
    raise RuntimeError('Not implemented')

def git_tb_restore():
    raise RuntimeError('Not implemented')

def git_tb_args():
    parser = argparse.ArgumentParser(
            prog=_.PROG,
            description='git toolbox')
    parser.add_argument(
            '-d', '--debug', help='Enable debug log level',
            action='store_true', dest='is_log_debug', default=False)
    parser.add_argument(
            '-v', '--verbose', help='Enable trace log level',
            action='store_true', dest='is_log_verbose', default=False)
    parser.add_argument(
            '-V', '--version', help='Show the tool version',
            action='store_true', dest='version', default='v1.0.0')
    subparsers = parser.add_subparsers(dest='command')

    print_parser = subparsers.add_parser(_.SUBCMD_LIST, help='List the repositories detected in the workspace')

    check_parser = subparsers.add_parser(_.SUBCMD_CHECK, help='Check repositories for pending local changes')

    pull_parser = subparsers.add_parser(_.SUBCMD_PULL, help='Run pull for all the repositories in the workspace')

    push_parser = subparsers.add_parser(_.SUBCMD_PUSH, help='Run push for all the repositories for upstream, or origin (the first found)')

    backup_parser = subparsers.add_parser(_.SUBCMD_BACKUP, help='Generate a "workspace.yaml" file that can be used to recover the workspace state')
    backup_parser.add_argument('name', help='Name of the item')

    restore_parser = subparsers.add_parser(_.SUBCMD_RESTORE, help='Restore from a "workspace.yaml" file all the repositories')
    restore_parser.add_argument('name', help='Name of the item')

    return parser

def setup_logs(args):
    logging.basicConfig(level=logging.INFO)
    if args.is_log_verbose:
        logging.basicConfig(level=logging.TRACE)
        logging.info('setting TRACE log level')
    if args.is_log_debug:
        logging.basicConfig(level=logging.DEBUG)
        logging.info('setting DEBUG log level')

def get_subcommands_map():
    return {
        _.SUBCMD_LIST: git_tb_list,
        _.SUBCMD_CHECK: git_tb_check,
        _.SUBCMD_PULL: git_tb_pull,
        _.SUBCMD_PUSH: git_tb_push,
        _.SUBCMD_BACKUP: git_tb_backup,
        _.SUBCMD_RESTORE: git_tb_restore,
    }

def main():
    SUBCOMMANDS = get_subcommands_map()
    args = git_tb_args().parse_args()
    setup_logs(args)
    subcommand = args.command
    if not subcommand in SUBCOMMANDS:
        git_tb_args().print_help()
        sys.exit(1)
    return SUBCOMMANDS[subcommand]()

if __name__ == '__main__':
    sys.exit(main())

