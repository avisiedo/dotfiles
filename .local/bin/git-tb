#!/usr/bin/python3
import sys
import os
import argparse
import logging
import subprocess

from datetime import datetime
import yaml

WORKSPACE = os.environ.get('WORKSPACE', os.path.join(os.environ['HOME'], 'workspace'))
_ARGS = None

class _:
    """Encapsulate the constants"""
    PROG = 'py-git-tb'
    KEY_CWD = 'cwd'
    KEY_CONTEXT = 'context'
    GIT = 'git'
    HIDDEN_GIT = '.git'
    UTF_8 = 'utf-8'
    # Environment variable with the ordered list of priorities for upstream
    # in the workspace; by default is set to 
    # "upstream,origin" => ['upstream', 'origin']
    ENV_GIT_REMOTES = 'GIT_REMOTES'
    GIT_REMOTES_DEFAULT = 'upstream,origin'

    # os.walk return dirpath on index 0
    WALK_DIRPATH = 0
    # os.walk return dirnames on index 1
    WALK_DIRNAMES = 1
    # os.walk return filenames on index 2
    WALK_FILENAMES = 2

    # Subcommands
    SUBCMD_LIST = 'list'
    SUBCMD_CHECK = 'check'
    SUBCMD_PULL = 'pull'
    SUBCMD_PUSH = 'push'
    SUBCMD_BACKUP = 'backup'
    SUBCMD_RESTORE = 'restore'

    # git commands
    GIT_CMD_REMOTE = 'remote'
    GIT_CMD_PUSH = 'push'
    GIT_CMD_PULL = 'pull'
    GIT_CMD_CLONE = 'clone'
    GIT_CMD_REMOTE = 'remote'
    GIT_CMD_STATUS = 'status'
    GIT_CMD_BRANCH = 'branch'

    # Ignore node_modules which use to have a huge directory structure
    FILTER_NODE_MODULES = 'node_modules'
    # Ignore .venv which use to have a huge directory structure
    FILTER_VENV = '.venv'
    # List for the directories to filter to accelerate the .git traverse.
    FILTERS = (FILTER_NODE_MODULES, FILTER_VENV)

    SUBP_CAPTURE_OUTPUT = 'capture_output'

    CHECK_MODIFIED = 'modified'
    CHECK_ADDED = 'added'
    CHECK_UNKNOWN = 'unknown'
    CHECK_NO_TRACKED = 'no-tracked'
    CHECK_DELETED = 'deleted'
    CHECK_NO_REMOTES = 'no-remotes'

    ERR_NOT_IMPLEMENTED = 'Not Implemented'

def git(*args, **kargs):
    """Wrapper to invoke git commands"""
    if not _.KEY_CWD in kargs:
        raise KeyError("'{}'".format(_.KEY_CWD))
    if not _.SUBP_CAPTURE_OUTPUT in kargs:
        kargs[_.SUBP_CAPTURE_OUTPUT] = True
    return subprocess.run([_.GIT, *args], **kargs)

def git_tb_all(basedir, f, *args, **kargs):
    for item in os.walk(basedir, topdown=True):
        if _.HIDDEN_GIT in item[_.WALK_DIRNAMES]:
            kargs[_.KEY_CWD] = basedir
            f(*args, **kargs)
        else:
            # Prune some well known directories
            for filter_item in _.FILTERS:
                if filter_item in item[_.WALK_DIRNAMES]:
                    item[_.WALK_DIRNAMES].remove(filter_item)
            # Recursive call to the remaining directories
            for new_dir in item[_.WALK_DIRNAMES]:
                git_tb_all(os.path.join(basedir, new_dir), f, *args, **kargs)
        break

def git_tb_list_helper(*args, **kargs):
    print('{}'.format(kargs[_.KEY_CWD]))

def git_tb_list():
    git_tb_all(WORKSPACE, git_tb_list_helper)

def git_tb_check_print(summary:dict):
    for key, value in summary.items():
        if key == _.CHECK_ADDED:
            print('added files: {}'.format(value))
        elif key == _.CHECK_MODIFIED:
            print('modified files: {}'.format(value))
        elif key == _.CHECK_DELETED:
            print('deleted files: {}'.format(value))
        elif key == _.CHECK_NO_TRACKED:
            print('no tracked files: {}'.format(value))
        elif key == _.CHECK_UNKNOWN:
            print('unknown: {}'.format(value))
        elif key == _.CHECK_NO_REMOTES:
            if value:
                print('has no remotes: {}'.format(value))
        else:
            print('warning: unexpected key {} with value {}'.format(key, value))

def git_tb_check_proc_general(summary: dict, cwd: str):
    """
    General checks based on 'git status --ignore-submodules --porcelain'

    @param summary Dictionary where to update the different keys about the states.
    @param cwd is the current working directory for the git repository to analyze.
    """
    result = git(_.GIT_CMD_STATUS, '--ignore-submodules', '--porcelain', cwd=cwd, capture_output=True)
    output = result.stdout.decode(_.UTF_8)
    if output == '':
        return
    lines = output.split('\n')
    if len(lines) == 0:
        return summary
    for line in lines:
        if line == '':
            continue
        if line[0:2] == ' M' or line[0:2] == 'M ':
            summary[_.CHECK_MODIFIED] = summary.get(_.CHECK_MODIFIED, 0) + 1
        elif line[0:2] == 'A ':
            summary[_.CHECK_ADDED] = summary.get(_.CHECK_ADDED, 0) + 1
        elif line[0:2] == 'D ' or line[0:2] == ' D':
            summary[_.CHECK_DELETED] = summary.get(_.CHECK_DELETED, 0) + 1
        elif line[0:2] == '??':
            summary[_.CHECK_NO_TRACKED] = summary.get(_.CHECK_NO_TRACKED, 0) + 1
        else:
            summary[_.CHECK_UNKNOWN] = summary.get(_.CHECK_UNKNOWN, 0) + 1

def git_tb_check_proc_remotes(summary: dict, cwd: str):
    """
    Verify if the repository has any remote, and if the remotes are on sync.

    @param summary is set _.CHECK_NO_REMOTES when no remotes, and
    _.CHECK_NO_ON_SYNC_REMOTES when some local branch is not on sync with the
    tracked remote branch, or no remote branch associated.
    @param cwd is the path to the git repo being analyzed.
    """
    remotes = git_read_remotes(cwd)
    if remotes is None or len(remotes) == 0:
        summary[_.CHECK_NO_REMOTES] = True

    # TODO Verify if local branches are on sync with remote ones
    if _ARGS.is_checking_remote:
        # TODO Check local branch are on sync with remotes
        pass

    # TODO Remove from the list of branches to check the ones that currently
    #      are merged
    result = git(_.GIT_CMD_BRANCH, '--merged', cwd=cwd, capture_output=True)
    pass

def git_tb_check_helper(*args, **kargs):
    _cwd = kargs[_.KEY_CWD]
    summary = {}

    # Analyze current repository
    git_tb_check_proc_general(summary, _cwd)
    git_tb_check_proc_remotes(summary, _cwd)

    # Print report for the current repository if exists any indicator
    if len(summary.keys()) > 0:
        logging.info('repository at: "{}"'.format(kargs[_.KEY_CWD]))
        git_tb_check_print(summary)

def git_tb_check():
    git_tb_all(WORKSPACE, git_tb_check_helper, stdout=None)

def git_tb_pull_helper(*args, **kargs):
    logging.info('repository at: "{}"'.format(kargs[_.KEY_CWD]))
    git(_.GIT_CMD_PULL, *args, **kargs)

def git_tb_pull(*args, **kargs):
    git_tb_all(WORKSPACE, git_tb_pull_helper)

def get_priority_git_remotes():
    remotes = os.environ.get(_.ENV_GIT_REMOTES, _.GIT_REMOTES_DEFAULT).split(',')
    return remotes

def git_tb_push_helper(*args, **kargs):
    try:
        cwd = kargs[_.KEY_CWD]
        res_remote = git(_.GIT_CMD_REMOTE, cwd=cwd)
        remotes = res_remote.stdout.decode(_.UTF_8).split_lines()
        for remote in get_priority_git_remotes():
            if remote in remotes:
                git(_.GIT_CMD_PUSH, remote, '--all', cwd=cwd)
                return
        logging.warning('{}: repository not pushed'.format(cwd))
    except Exception as e:
        logging.error('{}: {}'.format(cwd, e))

def git_tb_push():
    git_tb_all(WORKSPACE, git_tb_push_helper)

def git_remote_list(path):
    return git(_.GIT_CMD_REMOTE, cwd=path).stdout.decode(_.UTF_8).splitlines()

def git_read_remotes(path: str) -> list:
    try:
        data = []
        for key in git_remote_list(path):
            url = git(_.GIT_CMD_REMOTE, 'get-url', key, cwd=path).stdout.decode(_.UTF_8).split()[0]
            data.append({key: url})
        return data
    except Exception as e:
        logging.warning(e)
        return []

def helper_path_to_name(path:str) -> str:
    return os.path.realpath(path).replace('/','-').replace(' ', '-')

def git_tb_backup_helper(*args, **kargs):
    context = kargs[_.KEY_CONTEXT]
    workspace_name = helper_path_to_name(os.path.realpath(WORKSPACE)) + '-'
    name = helper_path_to_name(os.path.realpath(kargs[_.KEY_CWD]))
    name = name.removeprefix(workspace_name)
    path = os.path.realpath(kargs[_.KEY_CWD])
    remotes = git_read_remotes(path)
    if remotes is None or len(remotes) == 0:
        logging.warning('repository \'{}\' at: \'{}\' without remotes'.format(name, path))
    repo = {'name': name, 'path': path, 'remotes': remotes}
    context['repositories'].append(repo)

def git_tb_backup():
    current_data = {}
    if os.path.exists(WORKSPACE + '/' + 'workspace.yaml'):
        with open(WORKSPACE + '/' + 'workspace.yaml', 'rt') as fi:
            current_data = yaml.safe_load(fi)
    data = {"base": WORKSPACE,
            "upstream-order": os.environ.get(_.ENV_GIT_REMOTES, _.GIT_REMOTES_DEFAULT).split(','),
            "modified-at": datetime.now().isoformat(),
            "repositories": [],
    }
    git_tb_all(WORKSPACE, git_tb_backup_helper, context=data)
    data.update(current_data)
    with open(WORKSPACE + '/' + 'workspace.yaml', 'wt') as fo:
        fo.write('# file: workspace.yaml\n')
        fo.write('# generated by: git-tb backup\n')
        fo.write('---\n')
        yaml.safe_dump(data, fo)

def git_tb_restore():
    with open(WORKSPACE + '/' + 'workspace.yaml', 'rt') as fi:
        data = yaml.safe_load(fi)
    if 'modified-at' in data:
        print('last modified on: {}'.data['modified-at'])
    os.environ[_.ENV_GIT_REMOTES] = _.GIT_REMOTES_DEFAULT
    for repo in data['repositories']:
        if not repo.get('path', None):
            continue
        if not repo['remotes']:
            logging.warning('repository {} without remotes: passing'.format(WORKSPACE + '/' + name))
        for key, value in repo['remotes'].items():
            if not os.path.exists(WORKSPACE + '/' + repo['path']):
                _cwd = os.path.dirname(WORKSPACE + '/' + repo['path'])
                if not os.path.exist(_cwd):
                    os.path.mkdir(_cwd)
                git(_.GIT_CMD_CLONE, '--origin', cwd=WORKSPACE)
            else:
                git(_.GIT_CMD_REMOTE, 'add', '--origin', cwd=WORKSPACE + '/' + path)

def git_tb_args():
    parser = argparse.ArgumentParser(
            prog=_.PROG,
            description='git toolbox')
    parser.add_argument(
            '-d', '--debug', help='Enable debug log level',
            action='store_true', dest='is_log_debug', default=False)
    parser.add_argument(
            '-v', '--verbose', help='Enable trace log level',
            action='store_true', dest='is_log_verbose', default=False)
    parser.add_argument(
            '-V', '--version', help='Show the tool version',
            action='store_true', dest='version', default='v1.0.0')
    subparsers = parser.add_subparsers(dest='command')

    print_parser = subparsers.add_parser(_.SUBCMD_LIST, help='List the repositories detected in the workspace')
    check_parser = subparsers.add_parser(_.SUBCMD_CHECK, help='Check repositories for pending local changes')
    check_parser.add_argument(
            '--no-remote', help='Do not check remote sync',
            action='store_false', dest='is_checking_remote', default=True)

    pull_parser = subparsers.add_parser(_.SUBCMD_PULL, help='Run pull for all the repositories in the workspace')
    push_parser = subparsers.add_parser(_.SUBCMD_PUSH, help='Run push for all the repositories for upstream, or origin (the first found)')
    backup_parser = subparsers.add_parser(_.SUBCMD_BACKUP, help='Generate a \'workspace.yaml\' file that can be used to recover the workspace state')

    restore_parser = subparsers.add_parser(_.SUBCMD_RESTORE, help='Restore from a \'workspace.yaml\' file all the repositories')
    restore_parser.add_argument('name', help='Name of the item')

    return parser

def setup_logs(args):
    logging.basicConfig(level=logging.INFO)
    if args.is_log_verbose:
        logging.basicConfig(level=logging.TRACE)
        logging.info('setting TRACE log level')
    if args.is_log_debug:
        logging.basicConfig(level=logging.DEBUG)
        logging.info('setting DEBUG log level')

def get_subcommands_map():
    return {
        _.SUBCMD_LIST: git_tb_list,
        _.SUBCMD_CHECK: git_tb_check,
        _.SUBCMD_PULL: git_tb_pull,
        _.SUBCMD_PUSH: git_tb_push,
        _.SUBCMD_BACKUP: git_tb_backup,
        _.SUBCMD_RESTORE: git_tb_restore,
    }

def main():
    global _ARGS
    SUBCOMMANDS = get_subcommands_map()
    _ARGS = git_tb_args().parse_args()
    setup_logs(_ARGS)
    subcommand = _ARGS.command
    if not subcommand in SUBCOMMANDS:
        print('''git toolbox: helper to keep your git repositories in good shape\n''')
        git_tb_args().print_help()
        sys.exit(1)
    return SUBCOMMANDS[subcommand]()

if __name__ == '__main__':
    sys.exit(main())

