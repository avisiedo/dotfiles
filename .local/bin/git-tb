#!/usr/bin/python3
import sys
import os
import argparse
import logging
import subprocess

from datetime import datetime
import yaml

WORKSPACE = os.environ.get('WORKSPACE', os.path.join(os.environ['HOME'], 'workspace'))
_ARGS = None

class _:
    """Encapsulate the constants"""
    PROG = 'py-git-tb'
    KEY_CWD = 'cwd'
    KEY_CONTEXT = 'context'
    GIT = 'git'
    HIDDEN_GIT = '.git'
    UTF_8 = 'utf-8'
    # Environment variable with the ordered list of priorities for upstream
    # in the workspace; by default is set to 
    # "upstream,origin" => ['upstream', 'origin']
    ENV_GIT_REMOTES = 'GIT_REMOTES'
    GIT_REMOTES_DEFAULT = 'upstream,origin'

    # os.walk return dirpath on index 0
    WALK_DIRPATH = 0
    # os.walk return dirnames on index 1
    WALK_DIRNAMES = 1
    # os.walk return filenames on index 2
    WALK_FILENAMES = 2

    # Subcommands
    SUBCMD_LIST = 'list'
    SUBCMD_CHECK = 'check'
    SUBCMD_PULL = 'pull'
    SUBCMD_PUSH = 'push'
    SUBCMD_BACKUP = 'backup'
    SUBCMD_RESTORE = 'restore'

    # git commands
    GIT_CMD_REMOTE = 'remote'
    GIT_CMD_PUSH = 'push'
    GIT_CMD_PULL = 'pull'
    GIT_CMD_CLONE = 'clone'
    GIT_CMD_REMOTE = 'remote'
    GIT_CMD_STATUS = 'status'
    GIT_CMD_BRANCH = 'branch'
    GIT_CMD_REV_PARSE = 'rev-parse'
    GIT_CMD_FETCH = 'fetch'

    # Ignore node_modules which use to have a huge directory structure
    FILTER_NODE_MODULES = 'node_modules'
    # Ignore .venv which use to have a huge directory structure
    FILTER_VENV = '.venv'
    # List for the directories to filter to accelerate the .git traverse.
    FILTERS = (FILTER_NODE_MODULES, FILTER_VENV)

    SUBP_CAPTURE_OUTPUT = 'capture_output'

    CHECK_MODIFIED = 'modified'
    CHECK_ADDED = 'added'
    CHECK_UNKNOWN = 'unknown'
    CHECK_NO_TRACKED = 'no-tracked'
    CHECK_DELETED = 'deleted'
    CHECK_NO_REMOTES = 'no-remotes'
    CHECK_MISS_REMOTE = 'miss-remote-branch'
    CHECK_REMOTE_SYNC = 'not-synced'

    ERR_NOT_IMPLEMENTED = 'Not Implemented'

def git(*args, **kargs):
    """Wrapper to invoke git commands"""
    if not _.KEY_CWD in kargs:
        raise KeyError("'{}'".format(_.KEY_CWD))
    if not _.SUBP_CAPTURE_OUTPUT in kargs:
        kargs[_.SUBP_CAPTURE_OUTPUT] = True
    return subprocess.run([_.GIT, *args], **kargs)

def git_tb_all(basedir, f, *args, **kargs):
    for item in os.walk(basedir, topdown=True):
        if _.HIDDEN_GIT in item[_.WALK_DIRNAMES]:
            kargs[_.KEY_CWD] = basedir
            f(*args, **kargs)
        else:
            # Prune some well known directories
            for filter_item in _.FILTERS:
                if filter_item in item[_.WALK_DIRNAMES]:
                    item[_.WALK_DIRNAMES].remove(filter_item)
            # Recursive call to the remaining directories
            for new_dir in item[_.WALK_DIRNAMES]:
                git_tb_all(os.path.join(basedir, new_dir), f, *args, **kargs)
        break

def git_tb_list_helper(*args, **kargs):
    print('{}'.format(kargs[_.KEY_CWD]))

def git_tb_list():
    git_tb_all(WORKSPACE, git_tb_list_helper)

def git_tb_check_print(summary:dict):
    STR_ADD_FILES = 'added files: {}'
    STR_MOD_FILES = 'modified files: {}'
    STR_DEL_FILES = 'deleted files: {}'
    STR_NO_TRACK_FILES = 'no tracked files: {}'
    STR_UNKNOWN_FILES = 'unknown: {}'
    STR_NO_REMOTES = 'has no remotes: {}'
    STR_MISS_REMOTE = 'no remote branch for: {}'
    STR_REMOTE_SYNC = 'branches not sync on remote: {}'

    STR_UNEXPECTED_KEY_VALUE = 'unexpected key {} with value {}'
    for key, value in summary.items():
        if key == _.CHECK_ADDED:
            print(STR_ADD_FILES.format(value))
        elif key == _.CHECK_MODIFIED:
            print(STR_MOD_FILES.format(value))
        elif key == _.CHECK_DELETED:
            print(STR_DEL_FILES.format(value))
        elif key == _.CHECK_NO_TRACKED:
            print(STR_NO_TRACK_FILES.format(value))
        elif key == _.CHECK_UNKNOWN:
            print(STR_UNKNOWN_FILES.format(value))
        elif key == _.CHECK_NO_REMOTES:
            if value:
                print(STR_NO_REMOTES.format(value))
        elif key == _.CHECK_MISS_REMOTE:
            print(STR_MISS_REMOTE.format(value))
        elif key == _.CHECK_REMOTE_SYNC:
            print(STR_REMOTE_SYNC.format(value))
        else:
            logging.warning(STR_UNEXPECTED_KEY_VALUE.format(key, value))

def git_tb_check_proc_general(summary: dict, cwd: str):
    """
    General checks based on 'git status --ignore-submodules --porcelain'

    @param summary Dictionary where to update the different keys about the states.
    @param cwd is the current working directory for the git repository to analyze.
    """
    result = git(_.GIT_CMD_STATUS, '--ignore-submodules', '--porcelain', cwd=cwd, capture_output=True)
    output = result.stdout.decode(_.UTF_8)
    if output == '':
        return
    lines = output.split('\n')
    if len(lines) == 0:
        return summary
    for line in lines:
        if line == '':
            continue
        if line[0:2] == ' M' or line[0:2] == 'M ':
            summary[_.CHECK_MODIFIED] = summary.get(_.CHECK_MODIFIED, 0) + 1
        elif line[0:2] == 'A ':
            summary[_.CHECK_ADDED] = summary.get(_.CHECK_ADDED, 0) + 1
        elif line[0:2] == 'D ' or line[0:2] == ' D':
            summary[_.CHECK_DELETED] = summary.get(_.CHECK_DELETED, 0) + 1
        elif line[0:2] == '??':
            summary[_.CHECK_NO_TRACKED] = summary.get(_.CHECK_NO_TRACKED, 0) + 1
        else:
            summary[_.CHECK_UNKNOWN] = summary.get(_.CHECK_UNKNOWN, 0) + 1

def git_read_local_branches(cwd: str) -> list:
    try:
        result = git(_.GIT_CMD_BRANCH,
                     '--omit-empty',
                     '--no-color',
                     '--format=%(refname:short)',
                     cwd=cwd).stdout.decode(_.UTF_8)
        if not result:
            return []
        result = result.splitlines()
        result = [x for x in result if not x.startswith('heads/')]
        return result
    except Exception as e:
        # TODO Avoid no specific exception
        logging.error(e)
        return None

def git_read_remote_branches(cwd: str, remotes: list) -> list:
    try:
        result = git(_.GIT_CMD_BRANCH,
                     '--omit-empty',
                     '--no-color',
                     '--format=%(refname:short)',
                     '--remotes',
                     cwd=cwd).stdout.decode(_.UTF_8)
        if not result:
            return []
        result = result.splitlines()
        remotes = [list(x.keys())[0] for x in remotes]
        # We can receive something like:
        #
        # origin/2-make-generate-client
        # origin
        # origin/main
        # origin/update-license
        # origin/update-readme
        #
        # And we would need to remove the 'origin' entry.
        result = [x for x in result if x not in remotes]
        return result
    except Exception as e:
        # TODO Avoid no specific exception
        logging.error(e)
        return None

def git_tb_check_proc_remotes(summary: dict, cwd: str):
    """
    Verify if the repository has any remote, and if the remotes are on sync.

    @param summary is set _.CHECK_NO_REMOTES when no remotes, and
    _.CHECK_NO_ON_SYNC_REMOTES when some local branch is not on sync with the
    tracked remote branch, or no remote branch associated.
    @param cwd is the path to the git repo being analyzed.
    """
    remotes = git_read_remotes(cwd)
    if remotes is None or len(remotes) == 0:
        summary[_.CHECK_NO_REMOTES] = True

    # Detect if some local branch does not have remote, or if the local branch
    # is not on sync with the remote branch (should point the same commit)
    local_branches = git_read_local_branches(cwd)
    if local_branches:
        remote_branches = git_read_remote_branches(cwd, remotes)
        remote_branch = ""
        for branch in local_branches:
            was_found = False
            for remote in remotes:
                if list(remote.keys())[0] + '/' + branch in remote_branches:
                    remote_branch = list(remote.keys())[0] + '/' + branch
                    was_found = True
                    break
            if _ARGS.is_checking_remote:
                if was_found:
                    has_sync_commit = False
                    for remote in remotes:
                        if list(remote.keys())[0] + '/' + branch in remote_branches:
                            remote_branch = list(remote.keys())[0] + '/' + branch
                        local_hash = git(_.GIT_CMD_REV_PARSE, branch, cwd=cwd).stdout.decode(_.UTF_8)
                        remote_hash = git(_.GIT_CMD_REV_PARSE, remote_branch, cwd=cwd).stdout.decode(_.UTF_8)
                        if local_hash == remote_hash:
                            has_sync_commit = True
                            break
                    if not has_sync_commit:
                        summary[_.CHECK_REMOTE_SYNC] = summary.get(_.CHECK_REMOTE_SYNC, [])
                        summary[_.CHECK_REMOTE_SYNC].append(branch)
                else:
                    # This local branch has not homologous remote
                    summary[_.CHECK_MISS_REMOTE] = summary.get(_.CHECK_MISS_REMOTE, [])
                    summary[_.CHECK_MISS_REMOTE].append(branch)

def git_tb_check_helper(*args, **kargs):
    _cwd = kargs[_.KEY_CWD]
    summary = {}

    # Analyze current repository
    git_tb_check_proc_general(summary, _cwd)
    git_tb_check_proc_remotes(summary, _cwd)

    # Print report for the current repository if exists any indicator
    if len(summary.keys()) > 0:
        logging.info('repository at: "{}"'.format(kargs[_.KEY_CWD]))
        git_tb_check_print(summary)

def git_tb_check():
    git_tb_all(WORKSPACE, git_tb_check_helper, stdout=None)

def git_tb_pull_helper(*args, **kargs):
    logging.info('repository at: "{}"'.format(kargs[_.KEY_CWD]))
    git(_.GIT_CMD_PULL, *args, **kargs)

def git_tb_pull(*args, **kargs):
    git_tb_all(WORKSPACE, git_tb_pull_helper)

def get_priority_git_remotes():
    remotes = os.environ.get(_.ENV_GIT_REMOTES, _.GIT_REMOTES_DEFAULT).split(',')
    return remotes

def git_tb_push_helper(*args, **kargs):
    try:
        cwd = kargs[_.KEY_CWD]
        res_remote = git(_.GIT_CMD_REMOTE, cwd=cwd)
        remotes = res_remote.stdout.decode(_.UTF_8).split_lines()
        for remote in get_priority_git_remotes():
            if remote in remotes:
                git(_.GIT_CMD_PUSH, remote, '--all', cwd=cwd)
                return
        logging.warning('{}: repository not pushed'.format(cwd))
    except Exception as e:
        logging.error('{}: {}'.format(cwd, e))

def git_tb_push():
    git_tb_all(WORKSPACE, git_tb_push_helper)

def git_remote_list(path):
    return git(_.GIT_CMD_REMOTE, cwd=path).stdout.decode(_.UTF_8).splitlines()

def git_read_remotes(path: str) -> list:
    try:
        data = []
        for key in git_remote_list(path):
            url = git(_.GIT_CMD_REMOTE, 'get-url', key, cwd=path).stdout.decode(_.UTF_8).split()[0]
            data.append({key: url})
        return data
    except Exception as e:
        logging.warning(e)
        return []

def helper_path_to_name(path:str) -> str:
    return os.path.realpath(path).replace('/','-').replace(' ', '-')

def git_tb_backup_helper(*args, **kargs):
    context = kargs[_.KEY_CONTEXT]
    workspace_name = helper_path_to_name(os.path.realpath(WORKSPACE)) + '-'
    name = helper_path_to_name(os.path.realpath(kargs[_.KEY_CWD]))
    name = name.removeprefix(workspace_name)
    path = os.path.realpath(kargs[_.KEY_CWD])
    path = path.removeprefix(WORKSPACE + '/')
    remotes = git_read_remotes(path)
    if remotes is None or len(remotes) == 0:
        logging.warning('repository \'{}\' at: \'{}\' without remotes'.format(name, path))
    repo = {'name': name, 'path': path, 'remotes': remotes}
    context['repositories'].append(repo)

def git_tb_backup():
    current_data = {}
    if os.path.exists(WORKSPACE + '/' + 'workspace.yaml'):
        with open(WORKSPACE + '/' + 'workspace.yaml', 'rt') as fi:
            current_data = yaml.safe_load(fi)
    data = {"base": WORKSPACE,
            "upstream-order": os.environ.get(_.ENV_GIT_REMOTES, _.GIT_REMOTES_DEFAULT).split(','),
            "modified-at": datetime.now().isoformat(),
            "repositories": [],
    }
    git_tb_all(WORKSPACE, git_tb_backup_helper, context=data)
    data.update(current_data)
    with open(WORKSPACE + '/' + 'workspace.yaml', 'wt') as fo:
        fo.write('# file: workspace.yaml\n')
        fo.write('# generated by: git-tb backup\n')
        fo.write('---\n')
        yaml.safe_dump(data, fo)

def is_invalid_repo_path(path:str) -> bool:
    if not path:
        return True
    if path[0] == '/':
        return True
    if path[0:2] == '..':
        return True
    if '/../' in path:
        return True
    return False

def git_tb_restore():
    with open(WORKSPACE + '/' + 'workspace.yaml', 'rt') as fi:
        data = yaml.safe_load(fi)
    if 'modified-at' in data:
        print('last modified on: {}'.format(data['modified-at']))
    os.environ[_.ENV_GIT_REMOTES] = ','.join(data.get('upstream-order', _.GIT_REMOTES_DEFAULT.split(',')))

    for repo in data['repositories']:
        # Sanitize attributes
        name = repo.get('name', None)
        if not name:
            continue
        path = repo.get('path', None)
        if is_invalid_repo_path(path):
            logging.warning('ignoring repo: repo {} has invalid path {}'.format(name, path))
            continue
        if not repo['remotes']:
            logging.warning('ignoring repo: repo {} does not have remotes'.format(name))
            continue

        logging.info('restoring repo {} at {}'.format(name, path))
        target_path = WORKSPACE + '/' + path
        parent_target_path = os.path.dirname(target_path)
        if not os.path.exists(parent_target_path):
            os.mkdir(parent_target_path)

        for remote in repo['remotes']:
            for key, value in remote.items():
                if not os.path.exists(WORKSPACE + '/' + repo['path']):
                    git(_.GIT_CMD_CLONE, '--origin', key, value, target_path, cwd=parent_target_path)
                else:
                    git(_.GIT_CMD_REMOTE, 'add', key, value, cwd=target_path)
            git(_.GIT_CMD_FETCH, '--all', cwd=target_path)

def git_tb_args():
    parser = argparse.ArgumentParser(
            prog=_.PROG,
            description='git toolbox')
    parser.add_argument(
            '-d', '--debug', help='Enable debug log level',
            action='store_true', dest='is_log_debug', default=False)
    parser.add_argument(
            '-v', '--verbose', help='Enable trace log level',
            action='store_true', dest='is_log_verbose', default=False)
    parser.add_argument(
            '-V', '--version', help='Show the tool version',
            action='store_true', dest='version', default='v1.0.0')
    subparsers = parser.add_subparsers(dest='command')

    print_parser = subparsers.add_parser(_.SUBCMD_LIST, help='List the repositories detected in the workspace')
    check_parser = subparsers.add_parser(_.SUBCMD_CHECK, help='Check repositories for pending local changes')
    check_parser.add_argument(
            '--no-remote', help='Do not check remote sync',
            action='store_false', dest='is_checking_remote', default=True)

    pull_parser = subparsers.add_parser(_.SUBCMD_PULL, help='Run pull for all the repositories in the workspace')
    push_parser = subparsers.add_parser(_.SUBCMD_PUSH, help='Run push for all the repositories for upstream, or origin (the first found)')
    backup_parser = subparsers.add_parser(_.SUBCMD_BACKUP, help='Generate a \'workspace.yaml\' file that can be used to recover the workspace state')
    restore_parser = subparsers.add_parser(_.SUBCMD_RESTORE, help='Restore from a \'workspace.yaml\' file all the repositories')

    return parser

def setup_logs(args):
    logging.basicConfig(level=logging.INFO)
    if args.is_log_verbose:
        logging.basicConfig(level=logging.TRACE)
        logging.info('setting TRACE log level')
    if args.is_log_debug:
        logging.basicConfig(level=logging.DEBUG)
        logging.info('setting DEBUG log level')

def get_subcommands_map():
    return {
        _.SUBCMD_LIST: git_tb_list,
        _.SUBCMD_CHECK: git_tb_check,
        _.SUBCMD_PULL: git_tb_pull,
        _.SUBCMD_PUSH: git_tb_push,
        _.SUBCMD_BACKUP: git_tb_backup,
        _.SUBCMD_RESTORE: git_tb_restore,
    }

def main():
    global _ARGS
    SUBCOMMANDS = get_subcommands_map()
    _ARGS = git_tb_args().parse_args()
    setup_logs(_ARGS)
    subcommand = _ARGS.command
    if not subcommand in SUBCOMMANDS:
        print('''git toolbox: helper to keep your git repositories in good shape\n''')
        git_tb_args().print_help()
        sys.exit(1)
    return SUBCOMMANDS[subcommand]()

if __name__ == '__main__':
    sys.exit(main())

